/*
请设计一个空间复杂度为O(1)且时间上尽可能高效的算法，重新排列L中的各结点，得到线性表L'=(a1，an，a2，an-1，a3，an-2…)。要求：
(1) 给出算法的基本设计思想
(2) 根据设计思想，采用C或C++语言描述算法，关键之处给出注释。
(3) 说明你所设计的算法的时间复杂度。
*/

#include <stdio.h>
#include <stdlib.h>

typedef struct node {
int data;
struct node* next;
}NODE;

// 输入NODE
void scanfNODE(NODE *node);

// 输出NODE
void printlnNODE(NODE node);

// 重新排列各节点
void arrNODE(NODE *node);

int main()
{
    NODE node;
    scanfNODE(&node);
    printlnNODE(node);
    arrNODE(&node);
    printlnNODE(node);
    return 0;
}

void scanfNODE(NODE *node)
{
    int n;
    NODE *p = node,*newNode;
    while(scanf("%d",&n) && n!= -1)
    {
        newNode = (NODE*)malloc(sizeof(NODE));
        newNode->data = n;
        p->next = newNode;
        p=newNode;
    }
    p->next = NULL;
}

void printlnNODE(NODE node)
{
    NODE *p = node.next;
    while(p)
    {
        printf("%d  ",p->data);
        p = p->next;
    }
    printf("\n");
}

void arrNODE(NODE *node)
{
    int len=0,mid;
    NODE *lookP = node->next,*midP = node->next,*newMidP = NULL,*temp;
    while(lookP = lookP->next) ++len; // 得出链表长度
    mid = len/2;
    while(mid--) midP = midP->next; // midP指到链表中间
    // 倒转midP之后的链表成newMidP
    while(midP)
    {
        temp = midP->next;
        midP->next = newMidP;
        newMidP = midP;
        midP = temp;
    }
    lookP = node->next;
    // 按顺序接原表头与newMidP
    while(lookP)
    {
        temp = lookP->next;
        lookP->next = newMidP;
        lookP = newMidP;
        newMidP = temp;
    }
}
